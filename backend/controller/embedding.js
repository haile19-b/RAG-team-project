import { VoyageAIClient } from "voyageai";
import { Data } from "../model/data.model.js";
import { searchSimilarData } from "../Functions/searchSimilarData.js";
import { askGemini } from "../Functions/askForLastResponse.js";
import { ChunkFile } from "../Functions/askForChunking.js";

const client = new VoyageAIClient({ apiKey: process.env.VOYAGE_API_KEY });

export const embedData = async (req,res)=>{

    const {My_Data} = req.body;

    if(!My_Data){
        return res.status(400).json({
            message:"data is required !",
            success:false
        })
    }

    try {
        // here I'm trying to I'm trying to prevent the dubilication of the data and this can help in improving performance !

        // const storedData = await Data.findOne({text:My_Data})
        // if(storedData){
        //     return res.status(400).json({
        //         message:"the same data stored on the database!",
        //         success:false
        //     })
        // }

        const chunks = await ChunkFile(My_Data)

        if (chunks.error) {
            return res.status(400).json({
                message: `Chunking failed: ${chunks.error}`,
                status: false
            });
        }

        if (!chunks || chunks.length === 0) {
    return res.status(400).json({
        message: "No chunked data returned!",
        status: false
    });
}

const embededChunks = await Promise.all(
    chunks.map(async (chunk) => {
        try {
            const embeddingRes = await client.embed({
                input: chunk.chunk,
                model: "voyage-3-lite"
            });

            // âœ… ADD: Validate embedding response
            if (!embeddingRes.data || !embeddingRes.data[0] || !embeddingRes.data[0].embedding) {
                console.error("Invalid embedding response for chunk:", chunk.metadata.title);
                return null;
            }

            return {
                content: chunk.chunk,
                metadata: chunk.metadata,
                embedding: embeddingRes.data[0].embedding
            };
        } catch (embedError) {
            console.error(`Embedding failed for chunk "${chunk.metadata.title}":`, embedError);
            return null;
        }
    })
);

const successfulEmbeddings = embededChunks.filter(chunk => chunk !== null);

if (successfulEmbeddings.length === 0) {
    return res.status(500).json({
        message: "All embedding operations failed",
        status: false
    });
}


const documents = successfulEmbeddings.map((chunk)=>({
    content:chunk.content,
    metadata:chunk.metadata,
    embedding:chunk.embedding
}))

const bulkResult = await Data.insertMany(documents);

return res.json({
    message: "Chunks successfully processed and stored",
    summary: {
        totalReceived: chunks.length,
        successfullyEmbedded: successfulEmbeddings.length,
        successfullyStored: bulkResult.insertedCount,
        failures: chunks.length - successfulEmbeddings.length
    },
});

    } catch (error) {
        return res.status(500).json({
            message:"server error",
            error:error.message,
            success:false
        })
    }
}

export const getReleventData = async(req,res) => {

    const {text} = req.query;
    if(!text){
        return res.status(400).json({
            message:"what text is you are searching for ?, there is no text!",
            success:false
        })
    }

    try {
        const embedResponse = await client.embed({
            input:[text],
            model:'voyage-3'
        })

        const embededText = embedResponse.data[0].embedding;

        const relevantData = await searchSimilarData(embededText);

        const textForm = relevantData.map(data => data.text).join("\n");

        const AiResponse = await askGemini(text,textForm)

        return res.status(200).json({
            message:"response is successfully generated by gemini",
            userInput:text,
            aiResponse:AiResponse
        })

        // return res.status(200).json({
        //     message:"relevent data successfully filtered!",
        //     data:relevantData,
        //     combinedText:textForm
        // })

        

    } catch (error) {
        return res.status(500).json({
            message:"Server Error Occored",
            error:error.message
        })
    }

}